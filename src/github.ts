import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import { sortBy } from 'lodash'
import { ArrayElement } from './utils'
import * as jsonDiff from 'json-diff'
import { stringify } from 'querystring'

export type GithubIssue = ArrayElement<RestEndpointMethodTypes['issues']['listForRepo']['response']['data']>
export type GithubIssueTemplate = {
  title?: string | number | null | undefined
  body?: string | null | undefined
  labels?: (string | { name?: string | undefined })[] | null | undefined
  state?: string | null | undefined
}
export type GithubIssueTemplateNormalized = {
  title: string
  body: string[]
  labels: string[]
  state: string
}
export type GithubIssueBodyLineText = {
  type: 'text'
  text: string
}
export type GithubIssueBodyLineTask = {
  type: 'task'
  label: string
  done: boolean
  params: { [key: string]: string | undefined }
}
export type GithubIssueBodyLine = GithubIssueBodyLineText | GithubIssueBodyLineTask

export async function listAllGithubRepoIssuesByLabels(
  octokit: InstanceType<typeof Octokit>,
  owner: string,
  repo: string,
  filter?: { state?: 'open' | 'closed' | 'all'; labels?: string }
): Promise<GithubIssue[]> {
  const perPage = 100
  const issues: GithubIssue[] = []
  for (let page = 1; true; page++) {
    const issuesForPage = await octokit.issues
      .listForRepo({
        owner,
        repo,
        per_page: perPage,
        page,
        sort: 'created',
        state: filter?.state,
        labels: filter?.labels,
      })
      .then(res => res.data)
    issues.push(...issuesForPage)
    if (issuesForPage.length < perPage) {
      break
    }
  }
  return issues
}

function normalizeGithubIssue(issue: GithubIssueTemplate | undefined): GithubIssueTemplateNormalized {
  return {
    title: typeof issue?.title === 'number' ? issue?.title.toString() : issue?.title || '',
    body: (issue?.body || '').split('\n'),
    labels: sortBy(
      (issue?.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
      name => name
    ),
    state: issue?.state || 'open',
  }
}

export function compareGithubIssues(issue1: GithubIssueTemplate, issue2: GithubIssueTemplate): boolean {
  const i1n = normalizeGithubIssue(issue1)
  const i2n = normalizeGithubIssue(issue2)
  return (
    i1n.title === i2n.title &&
    i1n.body.join('\n') === i2n.body.join('\n') &&
    i1n.labels.join('\n') === i2n.labels.join('\n') &&
    i1n.state === i2n.state
  )
}

export function renderGithubIssueDiff(
  prev: GithubIssueTemplate | undefined,
  next: GithubIssueTemplate | undefined,
  color?: boolean
): string {
  const temp = jsonDiff.diffString(normalizeGithubIssue(prev), normalizeGithubIssue(next), { color })
  return temp
    .split('\n')
    .reduce<{ result: string[]; same?: { line: string; count: number } }>(
      (acc, line) => {
        const isTripleDot = line.trim() === '...'
        const sameLines = acc.same
          ? [acc.same.count === 1 ? acc.same.line : acc.same.line + ` (${acc.same.count})`]
          : []
        if (isTripleDot && !acc.same) {
          return { result: acc.result, same: { line, count: 1 } }
        } else if (isTripleDot && acc.same && acc.same.line !== line) {
          return { result: [...acc.result, ...sameLines], same: { line, count: 1 } }
        } else if (isTripleDot && acc.same && acc.same.line === line) {
          return { result: acc.result, same: { line: acc.same.line, count: acc.same.count + 1 } }
        } else {
          return { result: [...acc.result, ...sameLines, line] }
        }
      },
      { result: [] }
    )
    .result.join('\n')
}

export function renderGithubIssueBody(body: GithubIssueBodyLine[]): string {
  return body
    .map(line => {
      if (line.type === 'text') {
        return line.text
      } else if (line.type === 'task') {
        return `- [${line.done === true ? 'x' : ' '}] ${line.label}${Object.keys(line.params || {})
          .map(key => ` <!-- ${key}=${line.params[key]} -->`)
          .join('')}`
      } else {
        return ''
      }
    })
    .join('\n')
}

const taskRegex = /^- \[([x ])\] (.*)$/
const taskLabelParamRegex = / <!-- ([^ =]+)=([^ ]+) -->$/
export function parseGithubIssueBody(body: string): GithubIssueBodyLine[] {
  return body.split('\n').map(lineRaw => {
    const taskMatch = lineRaw.match(taskRegex)
    if (taskMatch) {
      const done = taskMatch[1] === 'x'
      let label = taskMatch[2]
      let params: GithubIssueBodyLineTask['params'] = {}
      while (true) {
        const taskLabelParamMatch = label.match(taskLabelParamRegex)
        if (taskLabelParamMatch) {
          label = label.substring(0, label.length - taskLabelParamMatch[0].length)
          params[taskLabelParamMatch[1]] = taskLabelParamMatch[2]
        } else {
          break
        }
      }
      return { type: 'task', label, done, params }
    } else {
      return { type: 'text', text: lineRaw }
    }
  })
}
