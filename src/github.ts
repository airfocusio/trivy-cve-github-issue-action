import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import { sortBy } from 'lodash'
import { ArrayElement } from './utils'

export type GithubIssue = ArrayElement<RestEndpointMethodTypes['issues']['listForRepo']['response']['data']>
export type GithubIssueTemplate = Pick<GithubIssue, 'title' | 'body' | 'labels' | 'state'>
export type GithubIssueBodyLineText = {
  type: 'text'
  text: string
}
export type GithubIssueBodyLineTask = {
  type: 'task'
  label: string
  done: boolean
  params: { [key: string]: string | undefined }
}
export type GithubIssueBodyLine = GithubIssueBodyLineText | GithubIssueBodyLineTask

export async function listAllGithubRepoIssuesByLabels(
  octokit: InstanceType<typeof Octokit>,
  owner: string,
  repo: string,
  filter?: { state?: 'open' | 'closed' | 'all'; labels?: string }
): Promise<GithubIssue[]> {
  const perPage = 100
  const issues: GithubIssue[] = []
  for (let page = 1; true; page++) {
    const issuesForPage = await octokit.issues
      .listForRepo({
        owner,
        repo,
        per_page: perPage,
        page,
        sort: 'created',
        state: filter?.state,
        labels: filter?.labels,
      })
      .then(res => res.data)
    issues.push(...issuesForPage)
    if (issuesForPage.length < perPage) {
      break
    }
  }
  return issues
}

export function compareGithubIssues(issue1: GithubIssueTemplate, issue2: GithubIssueTemplate): boolean {
  const cmpTitle = issue1.title === issue2.title
  const cmpBody = issue1.body === issue2.body
  const cmpState = issue1.state === issue2.state
  const issue1LabelNames = sortBy(
    (issue1.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const issue2LabelNames = sortBy(
    (issue2.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const cmpLabels = issue1LabelNames.join(',') === issue2LabelNames.join(',')
  return cmpTitle && cmpBody && cmpState && cmpLabels
}

export function renderGithubIssueBody(body: GithubIssueBodyLine[]): string {
  return body
    .map(line => {
      if (line.type === 'text') {
        return line.text
      } else if (line.type === 'task') {
        return `- [${line.done === true ? 'x' : ' '}] ${line.label}${Object.keys(line.params || {})
          .map(key => ` <!-- ${key}=${line.params[key]} -->`)
          .join('')}`
      } else {
        return ''
      }
    })
    .join('\n')
}

const taskRegex = /^- \[([x ])\] (.*)$/
const taskLabelParamRegex = / <!-- ([^ =]+)=([^ ]+) -->$/
export function parseGithubIssueBody(body: string): GithubIssueBodyLine[] {
  return body.split('\n').map(lineRaw => {
    const taskMatch = lineRaw.match(taskRegex)
    if (taskMatch) {
      const done = taskMatch[1] === 'x'
      let label = taskMatch[2]
      let params: GithubIssueBodyLineTask['params'] = {}
      while (true) {
        const taskLabelParamMatch = label.match(taskLabelParamRegex)
        if (taskLabelParamMatch) {
          label = label.substring(0, label.length - taskLabelParamMatch[0].length)
          params[taskLabelParamMatch[1]] = taskLabelParamMatch[2]
        } else {
          break
        }
      }
      return { type: 'task', label, done, params }
    } else {
      return { type: 'text', text: lineRaw }
    }
  })
}
