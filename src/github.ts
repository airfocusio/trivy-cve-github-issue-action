import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import { sortBy } from 'lodash'
import { ArrayElement } from './utils'

export type GithubIssue = ArrayElement<RestEndpointMethodTypes['issues']['listForRepo']['response']['data']>
export type GithubIssueTemplate = Pick<GithubIssue, 'title' | 'body' | 'labels' | 'state'>

export async function listAllGithubRepoIssuesByLabels(
  octokit: InstanceType<typeof Octokit>,
  owner: string,
  repo: string,
  filter?: { state?: 'open' | 'closed' | 'all'; labels?: string }
): Promise<GithubIssue[]> {
  const perPage = 100
  const issues: GithubIssue[] = []
  for (let page = 1; true; page++) {
    const issuesForPage = await octokit.issues
      .listForRepo({
        owner,
        repo,
        per_page: perPage,
        page,
        sort: 'created',
        state: filter?.state,
        labels: filter?.labels,
      })
      .then(res => res.data)
    issues.push(...issuesForPage)
    if (issuesForPage.length < perPage) {
      break
    }
  }
  return issues
}

export function compareGithubIssues(issue1: GithubIssueTemplate, issue2: GithubIssueTemplate): boolean {
  const cmpTitle = issue1.title === issue2.title
  const cmpBody = issue1.body === issue2.body
  const cmpState = issue1.state === issue2.state
  const issue1LabelNames = sortBy(
    (issue1.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const issue2LabelNames = sortBy(
    (issue2.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const cmpLabels = issue1LabelNames.join(',') === issue2LabelNames.join(',')
  return cmpTitle && cmpBody && cmpState && cmpLabels
}
