import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import { groupBy, sortBy, uniq, uniqBy, map } from 'lodash'
import { listAllGithubRepoIssuesByLabels, GithubIssue, GithubIssueTemplate, compareGithubIssues } from './github'
import { scrapeFilesForContainerImages } from './scrape'
import { execTrivyImageScan, execTrivyUpdateDatabase, TrivyResult, TrivySeverity } from './trivy'
import { getEnvBoolean, getEnvNumber, getEnvString } from './environment'
import { flatten, sequential, sha1 } from './utils'

export interface Vulnerability {
  id: string
  vulnerabilityID: string
  severity: TrivySeverity
  cvssNvdV3Vector?: string
  cvssNvdV3Score?: number
  title: string
  description: string
  references: string[]
  locations: VulnerabilityLocation[]
}

export interface VulnerabilityLocation {
  id: string
  artifactNameShort: string
  packageName: string
  versions: { artifactVersion: string; installedVersion: string; fixedVersion: string | undefined }[]
}

export interface VulnerabilityLocationDetails {
  artifactName: string
  installedVersion: string
  fixedVersion?: string
}

export function calculateTrivyResultID(result: TrivyResult): string {
  const id = [result.vulnerabilityID].join('/')
  return sha1(id)
}

export function calculateTrivyResultLocationID(result: TrivyResult): string {
  const id = [result.artifactName.split(':')[0], result.packageName].join('/')
  return sha1(id)
}

export interface Task {
  label: string
  done: boolean
  id?: string
}

export function extractTasksFromIssueBody(body: string, idKey: string): Task[] {
  function extractId(label: string): string | undefined {
    const regex = new RegExp(`<!-- ${idKey}-id=([0-9a-f]+) -->`)
    const match = label.match(regex)
    return match ? match[1] : undefined
  }

  const lines = body.match(/^- \[([x ])\] (.*)$/gm) || []
  return lines.flatMap(line => {
    const match = line.match(/^- \[([x ])\](.*)$/)
    return {
      label: match![2].trim(),
      done: !!match![1].trim(),
      id: extractId(match![2].trim()),
    }
  })
}

export function closeAllTasksInIssueBody(body: string, idKey: string): string {
  const regex = new RegExp(`^- \\[ \\] ((?:.*) <!-- ${idKey}-id=([0-9a-f]+) -->)$`, 'gm')
  return body.replace(regex, '- [x] $1')
}

export function renderVulnerabilityToGithubIssue(
  vulnerability: Vulnerability,
  existingIssue?: GithubIssue
): GithubIssueTemplate {
  const title = `[${vulnerability.vulnerabilityID}] ${vulnerability.title}`
  const locationTasks = vulnerability.locations.map(location => ({
    label: `artifact \`${location.artifactNameShort}\`, package \`${location.packageName}\` (${location.versions
      .map(v => `\`${location.artifactNameShort}:${v.artifactVersion}/${location.packageName}@${v.installedVersion}\``)
      .join(', ')}) <!-- location-id=${location.id} -->`,
    done: false,
    id: location.id,
  }))
  const existingIssueTasks = existingIssue
    ? extractTasksFromIssueBody(existingIssue.body || '', 'location').filter(t => !!t.id)
    : []
  const tasks = existingIssueTasks.reduce((tasks, task) => {
    if (task.id && tasks.find(t => t.id === task.id)) {
      return tasks
    } else {
      return [...tasks, task]
    }
  }, locationTasks)

  const body = [
    '## Overview',
    '',
    `ID: ${vulnerability.vulnerabilityID}`,
    `Severity: ${vulnerability.severity}`,
    `V3Vector: ${vulnerability.cvssNvdV3Vector}`,
    `V3Score: ${vulnerability.cvssNvdV3Score?.toFixed(1)}`,
    '',
    '## Locations',
    '',
    ...tasks.map(task => `- [${task.done ? 'x' : ' '}] ${task.label}`),
    '',
    '## Details',
    '',
    vulnerability.description,
    '',
    '## References',
    '',
    ...vulnerability.references.map(ref => `* ${ref}`),
    '',
    '---',
    '',
    vulnerability.id,
  ].join('\n')

  const labels = [{ name: 'trivy' }, vulnerability.severity !== 'UNKNOWN' ? { name: vulnerability.severity } : null]
    .filter(l => !!l)
    .map(l => l!)

  return {
    title,
    body,
    labels,
    state: 'open' as const,
  }
}

export async function run(): Promise<any> {
  const [owner, repo] = getEnvString('GITHUB_REPOSITORY').split('/')
  const debug = getEnvBoolean('DEBUG', false)
  const filesGlobs = getEnvString('FILES', '**/*.yaml')
    .split('\n')
    .map(fg => fg.trim())
    .filter(fg => !!fg)
  const severity = getEnvString('SEVERITY', 'CRITICAL,HIGH')
  const maxCounter = getEnvNumber('ISSUE_RATE_LIMIT', 10)

  const octokit = new Octokit()
  console.log(`Retrieving existing issues ...`)
  const existingIssues = await listAllGithubRepoIssuesByLabels(octokit, owner, repo, {
    labels: 'trivy',
    state: 'all',
  })

  console.log(`Scrapping files ${filesGlobs.join(', ')} for container images ...`)
  const containerImages = await scrapeFilesForContainerImages(filesGlobs).then(results =>
    sortBy(uniq(results.flatMap(f => f.containerImages)), i => i)
  )
  console.log('Updating trivy database ...')
  await execTrivyUpdateDatabase()

  console.log('Scanning images ...')
  const results = await sequential(
    containerImages.map(image => async () => {
      console.log(`Scanning image ${image} ...`)
      return execTrivyImageScan(image, severity)
    })
  ).then(flatten)

  const vulnerabilities = map(groupBy(results, calculateTrivyResultID), (results, id) => {
    return {
      id,
      vulnerabilityID: results[0].vulnerabilityID,
      severity: results[0].severity,
      cvssNvdV3Vector: results[0].cvssNvdV3Vector,
      cvssNvdV3Score: results[0].cvssNvdV3Score,
      title: results[0].title,
      description: results[0].description,
      references: results[0].references,
      locations: map(groupBy(results, calculateTrivyResultLocationID), (locations, id) => {
        return {
          id,
          artifactNameShort: locations[0].artifactName.split(':')[0],
          packageName: locations[0].packageName,
          versions: locations.map(l => ({
            artifactVersion: l.artifactName.split(':', 2)[1] || 'unknown',
            installedVersion: l.installedVersion,
            fixedVersion: l.fixedVersion,
          })),
        } as VulnerabilityLocation
      }),
    } as Vulnerability
  })
  console.log(`Found ${vulnerabilities.length} vulnerability groups in total`)

  let counter = 0
  await sequential(
    vulnerabilities.map(vulnerability => async () => {
      const existingIssue = existingIssues.find(i => (i.body || '').indexOf(vulnerability.id) >= 0)
      const issue = renderVulnerabilityToGithubIssue(vulnerability, existingIssue)

      if (!existingIssue) {
        console.log(`Creating issue: ${issue.title}`)
        const req: RestEndpointMethodTypes['issues']['create']['parameters'] = {
          owner,
          repo,
          title: issue.title || '',
          body: issue.body || '',
          state: issue.state == 'open' ? 'open' : 'closed',
          labels: issue.labels,
        }
        if (!debug) {
          if (counter < maxCounter) {
            await octokit.issues.create(req)
            counter++
          } else {
            console.log('Skipping due to rate limit')
          }
        } else {
          console.log(req)
        }
      } else if (
        !existingIssue.labels.find(l => (typeof l === 'string' ? l === 'trivy-ignore' : l.name === 'trivy-ignore')) &&
        !compareGithubIssues(existingIssue, issue)
      ) {
        console.log(`Updating issue: ${issue.title}`)
        const req: RestEndpointMethodTypes['issues']['update']['parameters'] = {
          owner,
          repo,
          issue_number: existingIssue.number,
          title: issue.title || '',
          body: issue.body || '',
          state: issue.state == 'open' ? 'open' : 'closed',
          labels: issue.labels,
        }
        if (!debug) {
          await octokit.issues.update(req)
        } else {
          console.log(req)
        }
      }
    })
  )

  await sequential(
    existingIssues
      .filter(
        i =>
          i.state !== 'closed' &&
          !i.labels.find(l => (typeof l === 'string' ? l === 'trivy-ignore' : l.name === 'trivy-ignore')) &&
          !Object.keys(vulnerabilities).find(key => (i.body || '').indexOf(key) >= 0)
      )
      .map(existingIssue => async () => {
        console.log(`Closing issue: ${existingIssue.title}`)
        const req: RestEndpointMethodTypes['issues']['update']['parameters'] = {
          owner,
          repo,
          issue_number: existingIssue.number,
          title: existingIssue.title,
          body: closeAllTasksInIssueBody(existingIssue.body || '', 'location'),
          state: 'closed' as const,
        }
        if (!debug) {
          await octokit.issues.update(req)
        } else {
          console.log(req)
        }
      })
  )
}
