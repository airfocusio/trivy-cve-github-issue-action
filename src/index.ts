import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import { groupBy, sortBy, uniq, map } from 'lodash'
import {
  listAllGithubRepoIssuesByLabels,
  GithubIssue,
  compareGithubIssues,
  GithubIssueBodyLineTask,
  parseGithubIssueBody,
  renderGithubIssueBody,
  GithubIssueBodyLineText,
  GithubIssueBodyLine,
  renderGithubIssueDiff,
} from './github'
import { scrapeFilesForContainerImages } from './scrape'
import { execTrivyImageScan, execTrivyUpdateDatabase, TrivyResult, TrivySeverity } from './trivy'
import { getEnvBoolean, getEnvNumber, getEnvString } from './environment'
import { flatten, sequential, sha1 } from './utils'

export interface Vulnerability {
  id: string
  vulnerabilityID: string
  severity: TrivySeverity
  cvssNvdV3Vector?: string
  cvssNvdV3Score?: number
  title: string
  description: string
  references: string[]
  locations: VulnerabilityLocation[]
}

export interface VulnerabilityLocation {
  id: string
  artifactNameShort: string
  packageName: string
  versions: { artifactVersion: string; installedVersion: string; fixedVersion: string | undefined }[]
}

export interface VulnerabilityLocationDetails {
  artifactName: string
  installedVersion: string
  fixedVersion?: string
}

export function calculateTrivyResultID(result: TrivyResult): string {
  const id = [result.vulnerabilityID].join('/')
  return sha1(id)
}

export function calculateTrivyResultLocationID(result: TrivyResult): string {
  const id = [result.artifactName.split(':')[0], result.packageName].join('/')
  return sha1(id)
}

export function generateVulnerabilityGithubIssueTitle(vulnerability: Vulnerability): string {
  return `[${vulnerability.vulnerabilityID}] ${vulnerability.title}`
}

export function generateVulnerabilityGithubIssueTasks(
  vulnerability: Vulnerability,
  existingIssue?: GithubIssue
): GithubIssueBodyLineTask[] {
  const existingIssueTasks = existingIssue
    ? parseGithubIssueBody(existingIssue.body || '')
        .filter(t => t.type === 'task' && !!t.params['location-id'])
        .map(t => t as GithubIssueBodyLineTask)
    : []
  const locationTasks: GithubIssueBodyLineTask[] = vulnerability.locations.map(location => {
    const doneManually = existingIssueTasks.find(
      t => t.params['location-id'] === location.id && t.done && t.params['auto-done'] !== 'true'
    )
    return {
      type: 'task',
      label: `artifact \`${location.artifactNameShort}\`, package \`${location.packageName}\` (${location.versions
        .map(
          v => `\`${location.artifactNameShort}:${v.artifactVersion}/${location.packageName}@${v.installedVersion}\``
        )
        .join(', ')})`,
      done: !!doneManually,
      params: {
        'location-id': location.id,
      },
    }
  })
  return existingIssueTasks.reduce((tasks, task) => {
    if (tasks.find(t => t.params['location-id'] === task.params['location-id'])) {
      return tasks
    } else {
      return [...tasks, { ...task, done: true, params: { ...task.params, 'auto-done': 'true' } }]
    }
  }, locationTasks)
}

export function generateVulnerabilityGithubIssueBody(
  vulnerability: Vulnerability,
  existingIssue?: GithubIssue
): GithubIssueBodyLine[] {
  const tasks = generateVulnerabilityGithubIssueTasks(vulnerability, existingIssue)
  const references = vulnerability.references.map(
    ref => ({ type: 'text', text: `* ${ref}` } as GithubIssueBodyLineText)
  )
  return [
    { type: 'text', text: '## Overview' },
    { type: 'text', text: '' },
    { type: 'text', text: `ID: ${vulnerability.vulnerabilityID}` },
    { type: 'text', text: `Severity: ${vulnerability.severity}` },
    { type: 'text', text: `V3Vector: ${vulnerability.cvssNvdV3Vector}` },
    { type: 'text', text: `V3Score: ${vulnerability.cvssNvdV3Score?.toFixed(1)}` },
    { type: 'text', text: '' },
    { type: 'text', text: '## Locations' },
    { type: 'text', text: '' },
    ...tasks,
    { type: 'text', text: '' },
    { type: 'text', text: '## Details' },
    { type: 'text', text: '' },
    { type: 'text', text: vulnerability.description },
    { type: 'text', text: '' },
    { type: 'text', text: '## References' },
    { type: 'text', text: '' },
    ...references,
    { type: 'text', text: '' },
    { type: 'text', text: '---' },
    { type: 'text', text: '' },
    { type: 'text', text: vulnerability.id },
  ]
}

export function generateVulnerabilityGithubIssueLabels(vulnerability: Vulnerability): { name: string }[] {
  return [{ name: 'trivy' }, vulnerability.severity !== 'UNKNOWN' ? { name: vulnerability.severity } : null]
    .filter(l => !!l)
    .map(l => l!)
}

export async function run(): Promise<any> {
  const [owner, repo] = getEnvString('GITHUB_REPOSITORY').split('/')
  const debug = getEnvBoolean('DEBUG', false)
  const filesGlobs = getEnvString('FILES', '**/*.yaml')
    .split('\n')
    .map(fg => fg.trim())
    .filter(fg => !!fg)
  const severity = getEnvString('SEVERITY', 'CRITICAL,HIGH').split(',') as TrivySeverity[]
  const maxCounter = getEnvNumber('ISSUE_RATE_LIMIT', 10)

  console.log(`Scrapping files ${filesGlobs.join(', ')} for container images ...`)
  const containerImages = await scrapeFilesForContainerImages(filesGlobs).then(results =>
    sortBy(uniq(results.flatMap(f => f.containerImages)), i => i)
  )
  console.log('Updating trivy database ...')
  await execTrivyUpdateDatabase()

  console.log('Scanning images ...')
  const results = await sequential(
    containerImages.map(image => async () => {
      console.log(`Scanning image ${image} ...`)
      return execTrivyImageScan(image, severity)
    })
  ).then(flatten)

  const vulnerabilities = map(groupBy(results, calculateTrivyResultID), (results, id) => {
    return {
      id,
      vulnerabilityID: results[0].vulnerabilityID,
      severity: results[0].severity,
      cvssNvdV3Vector: results[0].cvssNvdV3Vector,
      cvssNvdV3Score: results[0].cvssNvdV3Score,
      title: results[0].title,
      description: results[0].description,
      references: results[0].references,
      locations: map(groupBy(results, calculateTrivyResultLocationID), (locations, id) => {
        return {
          id,
          artifactNameShort: locations[0].artifactName.split(':')[0],
          packageName: locations[0].packageName,
          versions: locations.map(l => ({
            artifactVersion: l.artifactName.split(':', 2)[1] || 'unknown',
            installedVersion: l.installedVersion,
            fixedVersion: l.fixedVersion,
          })),
        } as VulnerabilityLocation
      }),
    } as Vulnerability
  })
  console.log(`Found ${vulnerabilities.length} vulnerability groups in total`)

  const octokit = new Octokit()
  console.log(`Retrieving existing issues ...`)
  const existingIssues = await listAllGithubRepoIssuesByLabels(octokit, owner, repo, {
    labels: 'trivy',
    state: 'all',
  })

  type Pair = {
    vulnerability: Vulnerability | undefined
    existingIssue: GithubIssue | undefined
  }
  const left: Pair[] = vulnerabilities
    .map<Pair>(v => ({
      vulnerability: v,
      existingIssue: existingIssues.find(i => (i.body || '').indexOf(v.id) >= 0),
    }))
    .filter(({ existingIssue: existingGithubIssue }) => !existingGithubIssue)
  const both: Pair[] = vulnerabilities
    .map<Pair>(v => ({
      vulnerability: v,
      existingIssue: existingIssues.find(i => (i.body || '').indexOf(v.id) >= 0),
    }))
    .filter(({ existingIssue: existingGithubIssue }) => !!existingGithubIssue)
  const right: Pair[] = existingIssues
    .filter(i => i.state === 'open')
    .map<Pair>(i => ({
      vulnerability: vulnerabilities.find(v => (i.body || '').indexOf(v.id) >= 0),
      existingIssue: i,
    }))
    .filter(({ vulnerability }) => !vulnerability)

  let counter = 0
  await sequential(
    [...left, ...both, ...right].map(({ vulnerability, existingIssue }) => async () => {
      if (vulnerability) {
        const title = generateVulnerabilityGithubIssueTitle(vulnerability)
        const bodyParsed = generateVulnerabilityGithubIssueBody(vulnerability, existingIssue)
        const body = renderGithubIssueBody(bodyParsed)
        const labels = generateVulnerabilityGithubIssueLabels(vulnerability)
        const state = bodyParsed.filter(l => l.type === 'task' && !l.done).length > 0 ? 'open' : ('closed' as const)

        if (!existingIssue && state === 'open') {
          console.log(`Creating issue: ${title}`)
          const req: RestEndpointMethodTypes['issues']['create']['parameters'] = {
            owner,
            repo,
            title,
            body,
            labels,
            state,
          }
          console.log(renderGithubIssueDiff(undefined, req))
          if (!debug) {
            if (counter < maxCounter) {
              await octokit.issues.create(req)
              counter++
            } else {
              console.log('Skipping due to rate limit')
            }
          }
        } else if (existingIssue && !compareGithubIssues({ title, body, labels, state }, existingIssue)) {
          console.log(`Updating issue: ${title}`)
          const req: RestEndpointMethodTypes['issues']['update']['parameters'] = {
            owner,
            repo,
            issue_number: existingIssue.number,
            title,
            body,
            state,
            labels,
          }
          console.log(renderGithubIssueDiff(existingIssue, req))
          if (!debug) {
            await octokit.issues.update(req)
          }
        }
      } else if (existingIssue) {
        const title = existingIssue.title
        const bodyParsed = parseGithubIssueBody(existingIssue.body || '').map(line => {
          if (line.type === 'task') {
            if (line.params['location-id'] && !line.done) {
              return { ...line, done: true, params: { ...line.params, 'auto-done': 'true' } }
            } else {
              return line
            }
          } else {
            return line
          }
        })
        const body = renderGithubIssueBody(bodyParsed)
        const labels = existingIssue.labels
        const state = bodyParsed.filter(l => l.type === 'task' && !l.done).length > 0 ? 'open' : ('closed' as const)

        if (existingIssue && !compareGithubIssues({ title, body, labels, state }, existingIssue)) {
          console.log(`Updating issue: ${title}`)
          const req: RestEndpointMethodTypes['issues']['update']['parameters'] = {
            owner,
            repo,
            issue_number: existingIssue.number,
            title,
            body,
            state,
            labels,
          }
          console.log(renderGithubIssueDiff(existingIssue, req))
          if (!debug) {
            await octokit.issues.update(req)
          }
        }
      }
    })
  )
}
