import { Octokit, RestEndpointMethodTypes } from '@octokit/action'
import * as crypto from 'crypto'
import { groupBy, sortBy, uniq, uniqBy } from 'lodash'
import * as fs from 'fs'
import { promisify } from 'util'
import * as yaml from 'js-yaml'
import { glob } from 'glob'
import * as childProcess from 'child_process'

const readFileAsync = promisify(fs.readFile)
const execFileAsync = promisify(childProcess.execFile)
const globAsync = promisify(glob)

type ArrayElement<ArrayType extends readonly unknown[]> = ArrayType extends readonly (infer ElementType)[]
  ? ElementType
  : never
type Image = { file: string; images: string[] }
type Result = { ID: string; HashID: string; Artifact: any; Vulnerability: any; Class: any }
type Issue = ArrayElement<RestEndpointMethodTypes['issues']['listForRepo']['response']['data']>
type IssueTemplate = Pick<Issue, 'title' | 'body' | 'labels' | 'state'>
type Task = { label: string; done: boolean }

async function sequential<T>(promiseFns: (() => Promise<T>)[]): Promise<T[]> {
  return await promiseFns.reduce<Promise<T[]>>(async (accP, promiseFn) => {
    const acc = await accP
    const result = await promiseFn()
    return [...acc, result]
  }, Promise.resolve([]))
}

function flatten<T>(arrayOfArrays: T[][]): T[] {
  return arrayOfArrays.flatMap(arrays => arrays)
}

async function trivy(...args: string[]): Promise<string> {
  const { stdout } = await execFileAsync('trivy', args)
  return stdout
}

async function scrapeFilesForImages(filesGlobs: string[]): Promise<Image[]> {
  const files = await sequential(filesGlobs.map(fg => () => globAsync(fg))).then(flatten)
  return await sequential<Image>(
    files.map(file => async () => {
      const content = await readFileAsync(file, 'utf8')
      const documents = yaml.loadAll(content)
      const images = documents.flatMap(contentYaml => {
        function traverse(elem: any): string[] {
          if (elem === undefined) {
            return []
          } else if (elem === null) {
            return []
          } else if (typeof elem === 'string') {
            return []
          } else if (typeof elem === 'number') {
            return []
          } else if (typeof elem === 'boolean') {
            return []
          } else if (Array.isArray(elem)) {
            return elem.flatMap(traverse)
          } else if (typeof elem === 'object') {
            return Object.keys(elem).flatMap(key => {
              if (key === 'image' && typeof elem[key] === 'string') {
                return [elem[key]]
              } else {
                return traverse(elem[key])
              }
            })
          } else {
            return []
          }
        }
        return traverse(contentYaml)
      })
      return { file, images } as Image
    })
  ).then(s => s.filter(({ images }) => images.length > 0))
}

async function listAllRepoIssuesByLabels(
  octokit: InstanceType<typeof Octokit>,
  owner: string,
  repo: string,
  filter?: { state?: 'open' | 'closed' | 'all'; labels?: string }
): Promise<Issue[]> {
  const perPage = 100
  const issues: Issue[] = []
  for (let page = 1; true; page++) {
    const issuesForPage = await octokit.issues
      .listForRepo({
        owner,
        repo,
        per_page: perPage,
        page,
        sort: 'created',
        state: filter?.state,
        labels: filter?.labels,
      })
      .then(res => res.data)
    issues.push(...issuesForPage)
    if (issuesForPage.length < perPage) {
      break
    }
  }
  return issues
}

function sha1(str: string): string {
  var shasum = crypto.createHash('sha1')
  shasum.update(str)
  return shasum.digest('hex').substring(0, 12)
}

function shallowCloneObject(obj: any, keysToExclude: string[] = []): any {
  return Object.keys(obj)
    .filter(key => keysToExclude.indexOf(key) < 0)
    .reduce((acc, key) => ({ ...acc, [key]: obj[key] }), {})
}

function calculateResultIdentifier(result: Omit<Result, 'ID' | 'HashID'>): Result {
  const id = [result.Vulnerability.VulnerabilityID].join('/')
  return {
    ID: id,
    HashID: sha1(id),
    ...result,
  }
}

function renderResultsToIssue(results: Result[], existingIssue?: Issue): IssueTemplate {
  const { HashID, Vulnerability } = results[0]

  const title = `[${Vulnerability.VulnerabilityID}] ${Vulnerability.Title}`

  const resultsTasks = results.map(result => ({
    label: `${result.Artifact.ArtifactName} ${result.Vulnerability.PkgName} (installed ${
      result.Vulnerability.InstalledVersion
    }, fixed ${result.Vulnerability.FixedVersion || '-'})`,
    done: false,
  }))
  const existingIssueTasks = uniqBy(existingIssue ? extractTasksFromIssue(existingIssue) : [], t => t.label)
  const tasks = resultsTasks.reduce(
    (tasks, task) => {
      const index = tasks.findIndex(t => t.label === task.label)
      if (index >= 0) {
        return [...tasks.slice(0, index), task, ...tasks.slice(index + 1)]
      } else {
        return [...tasks, task]
      }
    },
    existingIssueTasks.map(t => ({ ...t, done: true }))
  )

  const body = [
    '## Overview',
    '',
    `ID: ${Vulnerability.VulnerabilityID}`,
    `Severity: ${Vulnerability.Severity}`,
    `V3Vector: ${Vulnerability.CVSS?.nvd?.V3Vector}`,
    `V3Score: ${Vulnerability.CVSS?.nvd?.V3Score?.toFixed(1)}`,
    '',
    '## Packages',
    '',
    ...tasks.map(task => `- [${task.done ? 'x' : ' '}] ${task.label}`),
    '',
    '## Details',
    '',
    Vulnerability.Description,
    '',
    '## References',
    '',
    ...[Vulnerability.PrimaryURL, ...(Vulnerability.References || [])].map(ref => `* ${ref}`),
    '',
    '---',
    '',
    HashID,
  ].join('\n')

  const labels = [{ name: 'trivy' }, Vulnerability.Severity !== 'UNKNOWN' ? { name: Vulnerability.Severity } : null]
    .filter(l => !!l)
    .map(l => l!)

  return {
    title,
    body,
    labels,
    state: 'open' as const,
  }
}

function extractTasksFromIssue(issue: Issue): Task[] {
  const lines = (issue.body || '').match(/^- \[([x ])\] (.*)$/gm) || []
  return lines.flatMap(line => {
    const match = line.match(/^- \[([x ])\](.*)$/)
    return {
      label: match![2].trim(),
      done: !!match![1],
    }
  })
}

function closeAllTasksInIssue<T extends { body?: string | null }>(issue: T): T {
  return {
    ...issue,
    body: (issue.body || '').replace(/^- \[ \] /gm, '- [x] '),
  }
}

function compareIssues(issue1: IssueTemplate, issue2: IssueTemplate): boolean {
  const cmpTitle = issue1.title === issue2.title
  const cmpBody = issue1.body === issue2.body
  const cmpState = issue1.state === issue2.state
  const issue1LabelNames = sortBy(
    (issue1.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const issue2LabelNames = sortBy(
    (issue2.labels || []).map(l => (typeof l === 'string' ? l : l.name || '')),
    name => name
  )
  const cmpLabels = issue1LabelNames.join(',') === issue2LabelNames.join(',')
  return cmpTitle && cmpBody && cmpState && cmpLabels
}

async function run(): Promise<any> {
  const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/')
  const debug = ['true', 'yes', '1'].indexOf(process.env.DEBUG || '') >= 0
  const filesGlobs = (process.env.FILES || '**/*.yaml')
    .split('\n')
    .map(fg => fg.trim())
    .filter(fg => !!fg)
  const severity = process.env.SEVERITY || 'CRITICAL,HIGH'
  const maxCounter = parseInt(process.env.ISSUE_RATE_LIMIT || '', 10) || 10

  const octokit = new Octokit()
  console.error(`Retrieving existing issues ...`)
  const existingIssues = await listAllRepoIssuesByLabels(octokit, owner, repo, {
    labels: 'trivy',
    state: 'all',
  })

  console.error(`Scrapping files ${filesGlobs.join(', ')} ...`)
  const sources = await scrapeFilesForImages(filesGlobs)

  const images = sortBy(uniq(sources.flatMap(f => f.images)), i => i)
  console.error('Updating trivy database ...')
  await trivy('image', '--download-db-only')

  const results = await sequential(
    images.map(image => async () => {
      console.error(`Scanning image ${image} ...`)
      const output = JSON.parse(
        await trivy('image', image, '--security-checks', 'vuln', '--severity', severity, '--format', 'json')
      )
      const results: Result[] = (output?.Results || []).flatMap(result => {
        return (result?.Vulnerabilities || []).map(vulnerability => {
          return calculateResultIdentifier({
            Artifact: shallowCloneObject(output, ['SchemaVersion', 'Results']),
            Class: shallowCloneObject(result, ['Vulnerabilities']),
            Vulnerability: shallowCloneObject(vulnerability),
          })
        })
      })
      return results
    })
  ).then(flatten)

  const resultsGrouped = groupBy(results, result => result.HashID)
  console.error(`Found ${Object.keys(resultsGrouped).length} vulnerability groups in total`)

  let counter = 0
  await sequential(
    Object.keys(resultsGrouped).map(key => async () => {
      const results = resultsGrouped[key]
      const existingIssue = existingIssues.find(i => (i.body || '').indexOf(key) >= 0)
      const issue = renderResultsToIssue(results, existingIssue)

      if (!existingIssue) {
        console.error(`Creating issue: ${issue.title}`)
        const req: RestEndpointMethodTypes['issues']['create']['parameters'] = {
          owner,
          repo,
          title: issue.title || '',
          body: issue.body || '',
          state: issue.state == 'open' ? 'open' : 'closed',
          labels: issue.labels,
        }
        if (!debug) {
          if (counter < maxCounter) {
            await octokit.issues.create(req)
            counter++
          } else {
            console.error('Skipping due to rate limit')
          }
        } else {
          console.log(req)
        }
      } else if (
        !existingIssue.labels.find(l => (typeof l === 'string' ? l === 'trivy-ignore' : l.name === 'trivy-ignore')) &&
        !compareIssues(existingIssue, issue)
      ) {
        console.error(`Updating issue: ${issue.title}`)
        const req: RestEndpointMethodTypes['issues']['update']['parameters'] = {
          owner,
          repo,
          issue_number: existingIssue.number,
          title: issue.title || '',
          body: issue.body || '',
          state: issue.state == 'open' ? 'open' : 'closed',
          labels: issue.labels,
        }
        if (!debug) {
          await octokit.issues.update(req)
        } else {
          console.log(req)
        }
      }
    })
  )

  await sequential(
    existingIssues
      .filter(
        i =>
          i.state !== 'closed' &&
          !i.labels.find(l => (typeof l === 'string' ? l === 'trivy-ignore' : l.name === 'trivy-ignore')) &&
          !Object.keys(resultsGrouped).find(key => (i.body || '').indexOf(key) >= 0)
      )
      .map(existingIssue => async () => {
        console.error(`Updating issue: ${existingIssue.title}`)
        const req: RestEndpointMethodTypes['issues']['update']['parameters'] = closeAllTasksInIssue({
          owner,
          repo,
          issue_number: existingIssue.number,
          title: existingIssue.title,
          body: existingIssue.body,
          state: 'closed' as const,
        })
        if (!debug) {
          await octokit.issues.update(req)
        } else {
          console.log(req)
        }
      })
  )
}

run().catch(err => {
  console.error(err)
  process.exit(1)
})
